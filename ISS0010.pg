flags: 00
blocks: <p>Эта страница пустовата, здесь не хватает твоих полезных советов.</p><h2 id="commentsHeading">Комментарии:</h2><div class="userComment"><h3>Ссылки</h3><ul><li><a class="url http" href="http://staff.ttu.ee/~bgordon/oppetegevus/systeooria/">http://staff.ttu.ee/~bgordon/oppetegevus/systeooria/</a> - Вся важная информация.</li><li><a class="url http" href="http://www.dcc.ttu.ee/las/materjalid.htm">http://www.dcc.ttu.ee/las/materjalid.htm</a> - Пригодится ближе к лабораторным.</li></ul><h3>Свободное программное обеспечение (Лабораторные)</h3><p>Есть несколько программ, о которых вам будет полезно знать:<br /></p><ul><li><a class="url http outside" href="http://www.sagemath.org/">sage</a> - отлично подходит для различных вычислений, в чем-то функциональность пересекается с MATLAB, но для теории систем мало подходит, так как для этого там ничего нет.</li><li><a class="url http outside" href="http://sourceforge.net/projects/python-control/">python-control</a> - тут все понятно, вещь заточена именно для систем, но для всего остального подходит мало, да и всех приятных фишек sage тут нет.</li><li><strong><a class="url http outside" href="http://www.scilab.org/">Scilab</a></strong> - для нас практически полная альтернатива MATLAB. Если вас интересует только выполнение лабораторных, то можете не читать про sage и python-control</li></ul><h4>sage</h4><h5>Установка</h5><p>Скачать можно с <a class="url http outside" href="http://sagemath.org/">официального сайта</a>. Если для вашей платформы есть бинарник, то всё чудесно - качаете и используетсе. Для Debian почему-то его нет, придется компилировать&#x2026; Нет ничего страшного, весь процесс автоматизирован, но занимает несколько часов, поэтому оставляйте его на ночь. На моем средненьком лаптопе весь процесс длился около 8 часов.</p><h5>Занятие 0</h5><p>Отличия от MATLAB<br /></p><table class="user"><tr><th align="center">MATLAB </th><th align="center">sage </th></tr><tr><td>help command</td><td>help(command)</td></tr><tr><td>%</td><td># коментарии, как и все остальное, как в python</td></tr><tr><td>v = [1 2 3 4 3 2 1]</td><td>v = vector([1, 2, 3, 4, 3, 2, 1]) Если без vector(), тогда это список, а не вектор</td></tr><tr><td>v + 3</td><td>v + vector([3] * len(v))</td></tr><tr><td>A = [9 2 3; -1 3 4; 0 2 1]</td><td>A = matrix([[9, 2, 3], [-1, 3, 4], [0, 2, 1]])</td></tr><tr><td>A = [9 2 3; -1 3 4; 0 2 1]</td><td>A = matrix(3, [9, 2, 3, -1, 3, 4, 0, 2, 1])</td></tr><tr><td>At = A&#x2019;</td><td>At = A.transpose()</td></tr><tr><td>A(1,1)</td><td>A[0,0] - нумерация с нуля</td></tr><tr><td>A(3,3) = 4</td><td>A[2,2] = 4</td></tr><tr><td>row1 = 2:5</td><td>row1 = range(2, 6) - второе число не включается. Осторожнее с типом</td></tr><tr><td>row2 = 6:-0.5:3.5</td><td>[x * -0.5 + 6 for x in range(6)]</td></tr><tr><td>row2 = 6:-0.5:3.5</td><td>from numpy import arange; arange(6,3.5,0.5) # так себе вариант</td></tr><tr><td>A(2:3,1:2)</td><td>A[1:3,0:2] # да, именно с такими индексами</td></tr><tr><td>inv(A)</td><td>A.inverse()</td></tr><tr><td>diag(A)</td><td>A.diagonal()</td></tr><tr><td>eig(A)</td><td>A.eigenvalues()</td></tr><tr><td>p1 = poly(A)</td><td>p1 = A.charpoly()</td></tr><tr><td>roots(p1)</td><td>p1.complex_roots()</td></tr><tr><td>p2 = [1 -2 0 5]</td><td>p2 = x^3 -2*x^2 + 5 только перед этим нужно задать x вот так: R.&lt;x&gt; = QQ[]</td></tr><tr><td>conv(p1,p2)</td><td>p1*p2</td></tr></table><p>Поскольку практически всё является объектом, можете смело ставить точку и нажимать TAB для автодополнения. Стоит отметить, что это довольно полезная фича, так как помнить названия всех функций нереально. Но, к сожалению, в <strong>Scilab</strong> большая часть функций живет сама по себе, такой метод не сработает, а жаль.</p><h5>Занятие 1</h5><p>На этом нужная нам функциональность sage исчерпана, на следующих занятиях придется использовать что-то другое :)</p><h4>python-control</h4><p>В целом работает сам по себе, но для некоторых действий (таких как tf) вам понадобится slicot. Я слабо понимаю, что творится в голове автором slicot. С одной стороны, его исходный код открыт, с другой стороны, разработчик хочет деньги в том случае, если вы используете slicot в коммерческих целях. При этом версия 4.5 выложена под лицензией GPL, что дает возможность распространять программу в любых целях, не платя автору ни цента. И тут вроде бы все логично, но в debian репозитории последняя версия - 5.0.</p><p>Ладно, не суть.</p><p>Устанавливаем <a class="url http outside" href="http://slicot.org/">slicot</a>:<br /></p><pre class="real">sudo apt-get install libslicot0 libslicot-dev libslicot-doc</pre><p>Устанавливаем <a class="url http outside" href="https://github.com/avventi/Slycot">slycot</a>:<br /></p><pre class="real">sudo apt-get build-dep python-scipy # для этого в /etc/apt/sources.list должен быть соответствующий deb-src репозиторий
	sudo python setup.py install</pre><p>Вроде бы все, теперь python-control должен быть полнофункциональным.</p><p>Запускаем:<br /></p><pre class="real">ipython -pylab</pre><p>Внутри<br /></p><pre class="real">from control.matlab import *</pre><p>Если все прошло без ошибок, то можно начинать рассматривать занятия :)</p><h5>Занятие 0</h5><p>Нет информации&#x2026;</p><h5>Занятие 1</h5><p>Матрицы для систем можно вписывать так:</p><pre class="real">sys = ss('-1 2;0 -4', '1;2', '1 0;0 1', '0;0')
	или
	sys = ss([[-1, 2],[0, -4]], [[1],[2]], [[1, 0],[0, 1]], [[0],[0]])</pre><p>Отличия от MATLAB<br /></p><table class="user"><tr><th align="center">MATLAB </th><th align="center">python-control </th></tr><tr><td>rank(m)</td><td><strong>matrix_rank(m)</strong>, не путать с rank(m)</td></tr><tr><td>ss(A, B, C, D)</td><td>ss(A, B, C, D)</td></tr><tr><td>rss(n, m, r)</td><td>нет, в любом случае чаще всего матрицы нам известны</td></tr><tr><td>ctrb(sys)</td><td>ctrb(sys.A, sys.B)</td></tr><tr><td>obsv(sys)</td><td>obsv(sys.A, sys.C)</td></tr><tr><td>eig(sys)</td><td>eig(sys.A)</td></tr><tr><td>tf(sys)</td><td>tf(sys), а также может пригодиться tfdata(sys)</td></tr><tr><td>ltiview(sys)</td><td>Строить графики можно, но не так просто&#x2026;</td></tr><tr><td>dcgain(sys)</td><td>dcgain(sys)</td></tr><tr><td align="right"></td><td>sys.inputs - довольно удобно, можно узнать кол-во входов не глядя на матрицы</td></tr><tr><td align="right"></td><td>sys.outputs</td></tr><tr><td align="right"></td><td>sys.states</td></tr></table><h5>Занятие 2</h5><p>Поскольку подобия simulink в python-control конечно же нет, на следующих занятиях придется использовать <strong>Scilab</strong>.</p><h4>Scilab</h4><p>Большая часть функций совпадает в той или иной мере с MATLAB, что на самом деле обидно, все-таки лучше бы они в чем-то брали пример с Sage.</p><h5>Установка</h5><pre class="real">apt-get install scilab # что может быть проще? :)</pre><h4>Занятие 0</h4><p>Если что-то здесь не указано, значит оно полностью совпадает с синтаксисом MATLAB (ну или я просто забыл что-то написать).<br />Все следующие команды перечислены относительно PDF файлов занятий, выложенных <a class="url http outside" href="http://www.dcc.ttu.ee/las/materjalid.htm">здесь</a>.</p><table class="user"><tr><th align="center">MATLAB </th><th align="center">scilab </th></tr><tr><td>eig(A)</td><td>spec(A)</td></tr><tr><td>poly(A)</td><td>poly(A, &#x2018;x&#x2019;)</td></tr><tr><td>p2 = [1 -2 0 5]</td><td>p2 = poly([5 0 -2 1], &#x2018;x&#x2019;, &#x2018;c&#x2019;) - коэффициенты в обратную сторону. Если не указать третим параметром &#x2018;c&#x2019;, тогда первый массив является списком корней</td></tr><tr><td>conv(p1, p2)</td><td>p1*p2</td></tr></table><h4>Занятие 1</h4><table class="user"><tr><th align="center">MATLAB </th><th align="center">scilab </th></tr><tr><td>ss(A, B, C, D)</td><td>syslin(&#x2019;c&#x2019;,A,B,C[,D]) для непрерывных, syslin(&#x2019;d&#x2019;,A,B,C[,D]) для дискретных</td></tr><tr><td>rss(n, m, r)</td><td>ssrand(<strong>m, r, n</strong>) - обратите внимание на порядок параметров</td></tr><tr><td>ctrb(sys)</td><td>cont_mat(sys)</td></tr><tr><td>obsv(sys)</td><td>obsv_mat(sys)</td></tr><tr><td>eig(sys)</td><td>spec(sys.A)</td></tr><tr><td>tf(sys)</td><td>ss2tf(sys)</td></tr><tr><td>dcgain(sys)</td><td>?</td></tr><tr><td>ltiview(sys)</td><td>? Смотри ниже</td></tr></table><p>Построить графики можно примерно так:<br /></p><pre class="real">t=0:0.01:15
	y1 = csim('stem', t, sys)
	plot(t, y1)</pre><h4>Занятие 2</h4><table class="user"><tr><td>eye(4)</td><td>eye(4,4)</td></tr><tr><td>eig(sys)</td><td>spec(sys.A)</td></tr><tr><td>c2d(sys,0.1)</td><td>cls2dls(sys,0.1)</td></tr><tr><td>place</td><td>ppol</td></tr><tr><td>simulink</td><td>xcos</td></tr></table><h4>xcos</h4><p>Код можно писать в <strong>Simulation/Set context</strong>, как использовать переменные из основного окна - я не понял.</p><p>Всё остальное так же, как и в MATLAB. Вот некоторые жлементы, которые могут вам пригодиться:</p><ul><li>Continuous time systems/CLSS - очевидно</li><li>Discrete time systems/DLSS - тоже очевидно</li><li>Mathematical Operations/GAIN_f - пригодится при обратной связи.</li><li>Sources/CLOCK_c для тактирования CSCOPE и дискретных систем.</li><li>Sinks/CSCOPE для просмотра</li><li>Signal Routing/MUX и DEMUX - вряд ли пригодятся, но если что, то они тут.</li><li>Continuous time systems/TIME_DELAY и Discrete time systems/DELAY_f - Иногда при использовании обратной связи можно увидеть ошибку &#x201c;Algebraic loop&#x201d;. Чтобы её обойти, поставьте небольшой delay в обратную связь.</li></ul><p>Выглядеть это будет примерно вот так:<br />&#x2026; ?</p><p>Сразу советую в Simulation/Setup выставить маленький Final integration time, например 30, так как нас будет интересовать лишь начало симуляции.</p><h4>Занятие 3</h4><p>Всё примерно то же самое, что и в занятии 2.</p></div><div class="userComment"><p><a class="url http" href="http://forum.ee/t73681/ssteemiteooria/">http://forum.ee/t73681/ssteemiteooria/</a></p></div>
diff-minor: <p><strong>Changed:</strong></p>
	<div class="old"><p>&lt; <strong class="changes">==</strong>Süsteemiteooria <strong class="changes">[http://ois.ttu.ee/portal/page?_pageid=35,428610&amp;_dad=portal&amp;_schema=PORTAL&amp;p_action=view&amp;p_id=</strong>31211<strong class="changes">&amp;p_public=1&amp;p_mode=1]</strong></p></div><p><strong>to</strong></p>
	<div class="new"><p>&gt; <strong class="changes">#SUBTITLE</strong> Süsteemiteooria<br />&gt; <strong class="changes">#SUBURL: Course:</strong>31211</p></div>
ip: 89.235.239.240
ts: 1408847769
minor: 1
host: 89.235.223.25
username: Bot
revision: 11
diff-major: <p><strong>Changed:</strong></p>
	<div class="old"><p>&lt; |=MATLAB|=sage|</p></div><p><strong>to</strong></p>
	<div class="new"><p>&gt; |= MATLAB |= sage |</p></div><p><strong>Changed:</strong></p>
	<div class="old"><p>&lt; |=MATLAB|=python-control|</p></div><p><strong>to</strong></p>
	<div class="new"><p>&gt; |= MATLAB |= python-control |</p></div><p><strong>Changed:</strong></p>
	<div class="old"><p>&lt; |=MATLAB|=scilab|</p></div><p><strong>to</strong></p>
	<div class="new"><p>&gt; |= MATLAB |= scilab |</p></div><p><strong>Changed:</strong></p>
	<div class="old"><p>&lt; |=MATLAB|=scilab|</p></div><p><strong>to</strong></p>
	<div class="new"><p>&gt; |= MATLAB |= scilab |</p></div>
summary: Refactoring
languages: 
text: #SUBTITLE Süsteemiteooria
	#SUBURL: Course:31211
	Эта страница пустовата, здесь не хватает твоих полезных советов.
	
	----
	===Ссылки
	 * http://staff.ttu.ee/~bgordon/oppetegevus/systeooria/ - Вся важная информация.
	 * http://www.dcc.ttu.ee/las/materjalid.htm - Пригодится ближе к лабораторным.
	
	=== Свободное программное обеспечение (Лабораторные)
	Есть несколько программ, о которых вам будет полезно знать:
	 * [[http://www.sagemath.org/ sage]] - отлично подходит для различных вычислений, в чем-то функциональность пересекается с MATLAB, но для теории систем мало подходит, так как для этого там ничего нет.
	 * [[http://sourceforge.net/projects/python-control/ python-control]] - тут все понятно, вещь заточена именно для систем, но для всего остального подходит мало, да и всех приятных фишек sage тут нет.
	 * **[[http://www.scilab.org/ Scilab]]** - для нас практически полная альтернатива MATLAB. Если вас интересует только выполнение лабораторных, то можете не читать про sage и python-control
	
	==== sage
	
	=====Установка
	Скачать можно с [[http://sagemath.org/ официального сайта]]. Если для вашей платформы есть бинарник, то всё чудесно - качаете и используетсе. Для Debian почему-то его нет, придется компилировать... Нет ничего страшного, весь процесс автоматизирован, но занимает несколько часов, поэтому оставляйте его на ночь. На моем средненьком лаптопе весь процесс длился около 8 часов.
	
	=====Занятие 0
	Отличия от MATLAB
	|= MATLAB |= sage |
	|help command|help(command)|
	|%|# коментарии, как и все остальное, как в python|
	|v = [1 2 3 4 3 2 1]|v = vector([1, 2, 3, 4, 3, 2, 1]) Если без vector(), тогда это список, а не вектор|
	|v + 3|v + vector([3] * len(v))|
	|A = [9 2 3; -1 3 4; 0 2 1]|A = matrix([[9, 2, 3], [-1, 3, 4], [0, 2, 1]])|
	|A = [9 2 3; -1 3 4; 0 2 1]|A = matrix(3, [9, 2, 3, -1, 3, 4, 0, 2, 1])|
	|At = A'|At = A.transpose()|
	|A(1,1)|A[0,0] - нумерация с нуля|
	|A(3,3) = 4|A[2,2] = 4|
	|row1 = 2:5|row1 = range(2, 6) - второе число не включается. Осторожнее с типом|
	|row2 = 6:-0.5:3.5|[x * -0.5 + 6 for x in range(6)]|
	|row2 = 6:-0.5:3.5|from numpy import arange; arange(6,3.5,0.5) # так себе вариант|
	|A(2:3,1:2)|A[1:3,0:2] # да, именно с такими индексами|
	|inv(A)|A.inverse()|
	|diag(A)|A.diagonal()|
	|eig(A)|A.eigenvalues()|
	|p1 = poly(A)|p1 = A.charpoly()|
	|roots(p1)|p1.complex_roots()|
	|p2 = [1 -2 0 5]|p2 = x^3 -2*x^2 + 5 только перед этим нужно задать x вот так: R.<x> = QQ[]|
	|conv(p1,p2)|p1*p2|
	
	Поскольку практически всё является объектом, можете смело ставить точку и нажимать TAB для автодополнения. Стоит отметить, что это довольно полезная фича, так как помнить названия всех функций нереально. Но, к сожалению, в **Scilab** большая часть функций живет сама по себе, такой метод не сработает, а жаль.
	
	=====Занятие 1
	На этом нужная нам функциональность sage исчерпана, на следующих занятиях придется использовать что-то другое :)
	
	====python-control
	В целом работает сам по себе, но для некоторых действий (таких как tf) вам понадобится slicot. Я слабо понимаю, что творится в голове автором slicot. С одной стороны, его исходный код открыт, с другой стороны, разработчик хочет деньги в том случае, если вы используете slicot в коммерческих целях. При этом версия 4.5 выложена под лицензией GPL, что дает возможность распространять программу в любых целях, не платя автору ни цента. И тут вроде бы все логично, но в debian репозитории последняя версия - 5.0.
	
	Ладно, не суть.
	
	Устанавливаем [[http://slicot.org/ slicot]]:
	{{{
	sudo apt-get install libslicot0 libslicot-dev libslicot-doc
	}}}
	
	Устанавливаем [[https://github.com/avventi/Slycot slycot]]:
	{{{
	sudo apt-get build-dep python-scipy # для этого в /etc/apt/sources.list должен быть соответствующий deb-src репозиторий
	sudo python setup.py install
	}}}
	Вроде бы все, теперь python-control должен быть полнофункциональным.
	
	Запускаем:
	{{{
	ipython -pylab
	}}}
	Внутри
	{{{
	from control.matlab import *
	}}}
	Если все прошло без ошибок, то можно начинать рассматривать занятия :)
	
	=====Занятие 0
	Нет информации...
	
	=====Занятие 1
	Матрицы для систем можно вписывать так:
	
	{{{
	sys = ss('-1 2;0 -4', '1;2', '1 0;0 1', '0;0')
	или
	sys = ss([[-1, 2],[0, -4]], [[1],[2]], [[1, 0],[0, 1]], [[0],[0]])
	}}}
	
	Отличия от MATLAB
	|= MATLAB |= python-control |
	|rank(m)|**matrix_rank(m)**, не путать с rank(m)|
	|ss(A, B, C, D)|ss(A, B, C, D)|
	|rss(n, m, r)|нет, в любом случае чаще всего матрицы нам известны|
	|ctrb(sys)|ctrb(sys.A, sys.B)|
	|obsv(sys)|obsv(sys.A, sys.C)|
	|eig(sys)|eig(sys.A)|
	|tf(sys)|tf(sys), а также может пригодиться tfdata(sys)|
	|ltiview(sys)|Строить графики можно, но не так просто...|
	|dcgain(sys)|dcgain(sys)|
	| |sys.inputs - довольно удобно, можно узнать кол-во входов не глядя на матрицы|
	| |sys.outputs|
	| |sys.states|
	
	=====Занятие 2
	Поскольку подобия simulink в python-control конечно же нет, на следующих занятиях придется использовать **Scilab**.
	
	====Scilab
	Большая часть функций совпадает в той или иной мере с MATLAB, что на самом деле обидно, все-таки лучше бы они в чем-то брали пример с Sage.
	
	=====Установка
	{{{
	apt-get install scilab # что может быть проще? :)
	}}}
	====Занятие 0
	Если что-то здесь не указано, значит оно полностью совпадает с синтаксисом MATLAB (ну или я просто забыл что-то написать).
	Все следующие команды перечислены относительно PDF файлов занятий, выложенных [[http://www.dcc.ttu.ee/las/materjalid.htm здесь]].
	
	|= MATLAB |= scilab |
	|eig(A)|spec(A)|
	|poly(A)|poly(A, 'x')|
	|p2 = [1 -2 0 5]|p2 = poly([5 0 -2 1], 'x', 'c') - коэффициенты в обратную сторону. Если не указать третим параметром 'c', тогда первый массив является списком корней|
	|conv(p1, p2)|p1*p2|
	
	====Занятие 1
	|= MATLAB |= scilab |
	|ss(A, B, C, D)|syslin('c',A,B,C[,D]) для непрерывных, syslin('d',A,B,C[,D]) для дискретных|
	|rss(n, m, r)|ssrand(**m, r, n**) - обратите внимание на порядок параметров|
	|ctrb(sys)|cont_mat(sys)|
	|obsv(sys)|obsv_mat(sys)|
	|eig(sys)|spec(sys.A)|
	|tf(sys)|ss2tf(sys)|
	|dcgain(sys)|?|
	|ltiview(sys)|? Смотри ниже|
	
	Построить графики можно примерно так:
	{{{
	t=0:0.01:15
	y1 = csim('stem', t, sys)
	plot(t, y1)
	}}}
	
	====Занятие 2
	|eye(4)|eye(4,4)|
	|eig(sys)|spec(sys.A)|
	|c2d(sys,0.1)|cls2dls(sys,0.1)|
	|place|ppol|
	|simulink|xcos|
	
	====xcos
	Код можно писать в **Simulation/Set context**, как использовать переменные из основного окна - я не понял.
	
	Всё остальное так же, как и в MATLAB. Вот некоторые жлементы, которые могут вам пригодиться:
	
	 * Continuous time systems/CLSS - очевидно
	 * Discrete time systems/DLSS - тоже очевидно
	 * Mathematical Operations/GAIN_f - пригодится при обратной связи.
	 * Sources/CLOCK_c для тактирования CSCOPE и дискретных систем.
	 * Sinks/CSCOPE для просмотра
	 * Signal Routing/MUX и DEMUX - вряд ли пригодятся, но если что, то они тут.
	 * Continuous time systems/TIME_DELAY и Discrete time systems/DELAY_f - Иногда при использовании обратной связи можно увидеть ошибку "Algebraic loop". Чтобы её обойти, поставьте небольшой delay в обратную связь.
	
	Выглядеть это будет примерно вот так:
	... ?
	
	Сразу советую в Simulation/Setup выставить маленький Final integration time, например 30, так как нас будет интересовать лишь начало симуляции.
	
	====Занятие 3
	Всё примерно то же самое, что и в занятии 2.
	
	----
	
	http://forum.ee/t73681/ssteemiteooria/
	
lastmajor: 10
keep-ts: 1408847769
